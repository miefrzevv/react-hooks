// НЕ НАДО ИСПОЛЬЗОВАТЬ КОГДА ПОЛЬЗОВАТЕЛЬ ВЗАИМОДЕЙСТВУЕТ С ИНТЕРФЕЙСОМ(ввод чего то в инпут, нажатие на кнопку, открытие дропдауна), а использовать следует когда рендер можно сделать параллельным(показать какие то подсказки, переключение табов)

// в реакт 18 добавили конкурентный режим, может происходить несколько рендеров одновременно, рендер становится прерываемый(в любой момент можно поставить на паузу)

/*
Concurrent Mode (конкурентный режим) в React 18 был переименован и представлен как Concurrent Features (конкурентные возможности). Это новый набор функций React, которые позволяют улучшить пользовательский опыт за счет более гибкого и приоритетного рендера компонентов. Эти возможности автоматизированы и активируются разработчиком по мере использования новых API, таких как useTransition, startTransition, и других.

Основные концепции конкурентных возможностей
Плавность обновлений: Конкурентный режим позволяет React приостанавливать менее важные обновления (например, сложные вычисления) и отдавать приоритет более важным задачам (например, отклик на действия пользователя). Это обеспечивает более плавное взаимодействие с интерфейсом.

Интеррупция (прерывание): React может при необходимости прервать выполнение текущего рендера, если появляются более высокоприоритетные задачи, такие как отклики на нажатия кнопок или ввод текста.

Пакетирование (batching): В конкурентном режиме React автоматически объединяет множество изменений состояния, чтобы минимизировать число ререндеров, включая асинхронные изменения.

Асинхронные переходы: React позволяет различать переходы с высокой приоритетностью (например, отклик на нажатие кнопки) и асинхронные переходы (например, обновление списка на основе пользовательского ввода), чтобы не блокировать интерфейс.
*/

/*
Новые API для конкурентных возможностей
startTransition
Используется для обозначения менее приоритетных обновлений состояния, которые можно отложить. Например, если пользователь вводит текст в поле поиска, вы можете пометить обновление списка результатов как менее приоритетное.
*/

import { startTransition, useState } from 'react';

function App() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);

  const handleChange = (e) => {
    const value = e.target.value;
    setQuery(value);

    startTransition(() => {
      const filteredResults = performHeavyFiltering(value);
      setResults(filteredResults);
    });
  };

  return (
    <div>
      <input type="text" value={query} onChange={handleChange} />
      <ResultsList results={results} />
    </div>
  );
}

//В этом случае, пока обновляется список results, React не будет блокировать ввод текста.

/*
useTransition
Хук, который предоставляет более удобный способ работы с асинхронными переходами. Он возвращает массив из двух значений: isPending (флаг, указывающий, идет ли переход) и функцию startTransition.
*/

import { useTransition, useState } from 'react';

function App() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  const [isPending, startTransition] = useTransition();

  const handleChange = (e) => {
    const value = e.target.value;
    setQuery(value);

    startTransition(() => {
      const filteredResults = performHeavyFiltering(value);
      setResults(filteredResults);
    });
  };

  return (
    <div>
      <input type="text" value={query} onChange={handleChange} />
      {isPending ? <p>Loading...</p> : <ResultsList results={results} />}
    </div>
  );
}

//Пока переход активен (isPending === true), можно показывать индикатор загрузки.

/*
Преимущества конкурентных возможностей
Более отзывчивый интерфейс: Пользовательские действия (например, ввод текста, прокрутка) не блокируются даже при сложных вычислениях.

Улучшение производительности: React эффективно распределяет ресурсы и избегает выполнения ненужной работы.

Лучший UX для асинхронных операций: Отложенные обновления обеспечивают более плавный переход между состояниями приложения.
*/

/*
Ограничения и нюансы
Конкурентные возможности работают только с компонентами, рендерящимися через новый ReactDOM.createRoot.
Для работы некоторых API требуется включить Strict Mode в приложении.
Конкурентный рендеринг требует совместимости с библиотеками сторонних разработчиков.
*/